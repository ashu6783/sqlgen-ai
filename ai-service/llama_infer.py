import os
import time
import aiohttp
import json
from dotenv import load_dotenv
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from groq import Groq

load_dotenv()

app = FastAPI()

class QueryRequest(BaseModel):
    query: str

@app.get("/health")
async def health_check():
    return {"status": "ok"}

async def run_inference(prompt):
    try:
        client = Groq(api_key=os.getenv("GROQ_API_KEY"))

        completion = client.chat.completions.create(
            model="meta-llama/llama-4-maverick-17b-128e-instruct",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
            max_completion_tokens=4096,
            top_p=1,
            stream=True,
            stop=None
        )

        sql = ""
        for chunk in completion:
            content = chunk.choices[0].delta.content or ""
            sql += content

        sql = sql.strip()
        if not sql:
            raise Exception("No SQL generated by Groq API")
        return sql
    except Exception as e:
        raise Exception(f"Inference failed: {str(e)}")

@app.post("/generate")
async def generate_sql(request: QueryRequest):
    try:
        async with aiohttp.ClientSession() as session:
            schema_url = os.getenv("SCHEMA_API_URL")
            async with session.get(f"{schema_url}/schema") as response:
                if response.status != 200:
                    raise HTTPException(status_code=500, detail='Failed to fetch schema')
                schema = await response.json()
            
            prompt = create_prompt(request.query, schema)
            sql = await run_inference(prompt)
            
            if not sql:
                raise HTTPException(status_code=500, detail="No SQL generated by inference service")
            
            return {"sql": sql}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def create_prompt(nlq, schema):
    try:
        if not isinstance(schema, list):
            raise ValueError(f"Schema must be a list, got {type(schema)}")
        for table in schema:
            if not isinstance(table, dict) or 'table' not in table or 'columns' not in table:
                raise ValueError(f"Invalid table format: {table}")
            if not isinstance(table['columns'], list):
                raise ValueError(f"Columns must be a list, got {type(table['columns'])}")
            for col in table['columns']:
                if not isinstance(col, dict) or 'name' not in col or 'type' not in col:
                    raise ValueError(f"Invalid column format: {col}")

        schema_str = "\n".join(
            [
                f"Table: {table['table']}\nColumns: {', '.join([f'{col['name']} ({col['type']})' for col in table['columns']])}"
                for table in schema
            ]
        )

        relationships = """
Relationships:
- Table 'customers' is linked to table 'orders' via customers.id = orders.customer_id
- Table 'orders' is linked to table 'order_items' via orders.id = order_items.order_id
- Table 'orders' is linked to table 'payments' via orders.id = payments.order_id
- Table 'orders' is linked to table 'shipping' via orders.id = shipping.order_id
- Table 'products' is linked to table 'order_items' via products.id = order_items.product_id
"""

        prompt = f"""
Given the following database schema:
{schema_str}

{relationships}

Given the following natural language query:
{nlq}

Generate a valid SQL query to answer the request. Ensure the query:
- Includes appropriate table names and aliases (e.g., 'customers c', 'orders o').
- Uses JOINs to link tables based on the relationships provided.
- Includes a GROUP BY clause if aggregation (e.g., SUM, COUNT) is used.
- Returns only the SQL query, without any additional text or explanations.

Example:
For "Show customer names and their total spent":
SELECT c.first_name, c.last_name, SUM(o.amount) AS total_spent
FROM customers c
JOIN orders o ON c.id = o.customer_id
GROUP BY c.id, c.first_name, c.last_name;
"""
        return prompt
    except Exception as e:
        raise ValueError(f"Failed to create prompt: {str(e)}")
